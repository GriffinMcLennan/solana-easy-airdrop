use airdrop_contract::accounts::CreateAirdrop;
use anchor_client::solana_sdk::commitment_config::CommitmentConfig;
use anchor_client::solana_sdk::pubkey::Pubkey;
use anchor_client::solana_sdk::signature::{read_keypair_file, Keypair, Signer};
use anchor_client::solana_sdk::transaction::Transaction;
#[allow(deprecated)]
use solana_sdk::system_program;
use anchor_client::Client;
use anchor_client::Cluster;
use anchor_spl::associated_token::get_associated_token_address;
use anchor_spl::token::spl_token;
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use solana_client::rpc_client::RpcClient;
use solana_sdk::program_pack::Pack;
use solana_sdk::system_instruction;
use spl_token::state::Mint;
use std::{fs::File, path::PathBuf, rc::Rc, str::FromStr};

// Default program ID from Anchor.toml
const DEFAULT_PROGRAM_ID: &str = "F6fHBUyYyaW14CxjSnJjLck8vMmWew3PbCnt5TMqRdZX";
const MINT_DECIMALS: u8 = 6;

#[derive(Deserialize, Serialize)]
struct ClaimInfo {
    amount: String,
    leaf_index: u64,
}

#[derive(Deserialize, Serialize)]
struct AirdropJson {
    merkle_root: [u8; 32],
    merkle_tree: Vec<Vec<u8>>,
    claims: std::collections::BTreeMap<String, ClaimInfo>,
    #[serde(default)]
    mint: Option<String>,
}

#[derive(Clone, Copy, Debug)]
pub enum Network {
    Devnet,
    Testnet,
    Mainnet,
    Localnet,
}

impl FromStr for Network {
    type Err = anyhow::Error;
    fn from_str(s: &str) -> Result<Self> {
        match s.to_lowercase().as_str() {
            "devnet" => Ok(Network::Devnet),
            "testnet" => Ok(Network::Testnet),
            "mainnet" | "mainnet-beta" => Ok(Network::Mainnet),
            "localnet" | "localhost" => Ok(Network::Localnet),
            _ => anyhow::bail!("Invalid network: {}. Use devnet, testnet, mainnet, or localnet", s),
        }
    }
}

impl Network {
    pub fn to_cluster(&self) -> Cluster {
        match self {
            Network::Devnet => Cluster::Devnet,
            Network::Testnet => Cluster::Testnet,
            Network::Mainnet => Cluster::Mainnet,
            Network::Localnet => Cluster::Localnet,
        }
    }

    pub fn name(&self) -> &'static str {
        match self {
            Network::Devnet => "devnet",
            Network::Testnet => "testnet",
            Network::Mainnet => "mainnet",
            Network::Localnet => "localnet",
        }
    }

    fn rpc_url(&self) -> &'static str {
        match self {
            Network::Devnet => "https://api.devnet.solana.com",
            Network::Testnet => "https://api.testnet.solana.com",
            Network::Mainnet => "https://api.mainnet-beta.solana.com",
            Network::Localnet => "http://localhost:8899",
        }
    }
}

#[derive(Debug)]
pub struct DeployAirdropArgs {
    pub json_path: PathBuf,
    pub mint: Option<String>,
    pub network: Network,
    pub program_id: String,
    pub keypair_path: PathBuf,
}

pub fn deploy_airdrop(args: DeployAirdropArgs) -> Result<()> {
    // Check file extension
    let extension = args.json_path.extension().and_then(|e| e.to_str()).unwrap_or("");
    if extension == "csv" {
        anyhow::bail!(
            "Expected a JSON file, but got a CSV file.\n\
            First generate the airdrop JSON using:\n  \
            cargo run -- create-merkle-tree --input {:?}\n\
            Then deploy using:\n  \
            cargo run -- deploy-airdrop --json ./airdrop.json",
            args.json_path
        );
    }

    // Read and parse the airdrop JSON
    let file = File::open(&args.json_path)
        .with_context(|| format!("Failed to open {:?}", args.json_path))?;
    let mut airdrop_data: AirdropJson = serde_json::from_reader(file).with_context(|| {
        format!(
            "Failed to parse airdrop JSON from {:?}. Make sure you're using an airdrop.json file \
            generated by 'create-merkle-tree', not a CSV file.",
            args.json_path
        )
    })?;

    // Calculate total amount from claims
    let total_amount: u64 = airdrop_data
        .claims
        .values()
        .map(|claim| claim.amount.parse::<u64>().unwrap_or(0))
        .sum();

    let merkle_root_hash = airdrop_data.merkle_root;
    let program_id = Pubkey::from_str(&args.program_id)?;

    println!("Merkle root: {}", hex::encode(merkle_root_hash));
    println!("Network: {}", args.network.name());
    println!("Program ID: {}", program_id);
    println!("Total amount (from claims): {}", total_amount);
    println!("Number of recipients: {}", airdrop_data.claims.len());

    // Load keypair
    let payer = read_keypair_file(&args.keypair_path)
        .map_err(|e| anyhow::anyhow!("Failed to read keypair from {:?}: {}", args.keypair_path, e))?;

    println!("Payer: {}", payer.pubkey());

    // Create RPC client for direct operations (use confirmed commitment for faster tx confirmation)
    let rpc_client = RpcClient::new_with_commitment(
        args.network.rpc_url().to_string(),
        CommitmentConfig::confirmed(),
    );

    // Determine mint - either use provided or create new one
    let (mint_pubkey, mint_keypair) = match &args.mint {
        Some(mint_str) => {
            let mint = Pubkey::from_str(mint_str)?;
            println!("Using existing mint: {}", mint);
            (mint, None)
        }
        None => {
            println!("\nNo mint provided, creating new token mint...");
            let mint_kp = Keypair::new();
            println!("New mint address: {}", mint_kp.pubkey());
            (mint_kp.pubkey(), Some(mint_kp))
        }
    };

    // Create Anchor client
    let client = Client::new_with_options(
        args.network.to_cluster(),
        Rc::new(Keypair::from_bytes(&payer.to_bytes())?),
        CommitmentConfig::confirmed(),
    );
    let program = client.program(program_id)?;

    // Derive PDAs
    let (merkle_root_pda, _bump) = Pubkey::find_program_address(
        &[b"merkle_root", &merkle_root_hash],
        &program_id,
    );

    let authority = program.payer();
    let authority_token_account = get_associated_token_address(&authority, &mint_pubkey);
    let merkle_root_token_account = get_associated_token_address(&merkle_root_pda, &mint_pubkey);

    println!("Merkle root PDA: {}", merkle_root_pda);
    println!("Authority token account: {}", authority_token_account);
    println!("Merkle root token account: {}", merkle_root_token_account);

    // If we need to create a mint, do it in a separate transaction first
    if let Some(ref mint_kp) = mint_keypair {
        println!("\nCreating mint and minting tokens...");

        let rent = rpc_client.get_minimum_balance_for_rent_exemption(Mint::LEN)?;

        // Create mint account
        let create_mint_ix = system_instruction::create_account(
            &payer.pubkey(),
            &mint_kp.pubkey(),
            rent,
            Mint::LEN as u64,
            &spl_token::ID,
        );

        // Initialize mint
        let init_mint_ix = spl_token::instruction::initialize_mint(
            &spl_token::ID,
            &mint_kp.pubkey(),
            &payer.pubkey(),
            Some(&payer.pubkey()),
            MINT_DECIMALS,
        )?;

        // Create authority's associated token account
        let create_ata_ix = spl_associated_token_account::instruction::create_associated_token_account(
            &payer.pubkey(),
            &payer.pubkey(),
            &mint_kp.pubkey(),
            &spl_token::ID,
        );

        // Mint tokens to authority
        let mint_to_ix = spl_token::instruction::mint_to(
            &spl_token::ID,
            &mint_kp.pubkey(),
            &authority_token_account,
            &payer.pubkey(),
            &[],
            total_amount,
        )?;

        let recent_blockhash = rpc_client.get_latest_blockhash()?;
        let tx = Transaction::new_signed_with_payer(
            &[create_mint_ix, init_mint_ix, create_ata_ix, mint_to_ix],
            Some(&payer.pubkey()),
            &[&payer, mint_kp],
            recent_blockhash,
        );

        let sig = rpc_client.send_and_confirm_transaction(&tx)?;
        println!("Mint created: {}", sig);
    }

    println!("\nSending create airdrop transaction...");

    // Build and send transaction using the program's instruction
    let signature = program
        .request()
        .accounts(CreateAirdrop {
            authority,
            authority_token_account,
            merkle_root_token_account,
            mint: mint_pubkey,
            merkle_root: merkle_root_pda,
            system_program: system_program::ID,
            token_program: spl_token::ID,
            associated_token_program: anchor_spl::associated_token::ID,
        })
        .args(airdrop_contract::instruction::CreateAirdrop {
            merkle_root_hash,
            amount: total_amount,
        })
        .send()?;

    println!("\nAirdrop deployed successfully!");
    println!("Signature: {}", signature);
    println!("Mint: {}", mint_pubkey);
    println!(
        "Explorer: https://explorer.solana.com/tx/{}?cluster={}",
        signature,
        args.network.name()
    );

    // Update the JSON file with the mint address
    airdrop_data.mint = Some(mint_pubkey.to_string());
    let file = File::create(&args.json_path)
        .with_context(|| format!("Failed to open {:?} for writing", args.json_path))?;
    serde_json::to_writer_pretty(file, &airdrop_data)
        .with_context(|| "Failed to write updated airdrop JSON")?;
    println!("\nUpdated {:?} with mint address", args.json_path);

    Ok(())
}

pub fn get_default_program_id() -> String {
    DEFAULT_PROGRAM_ID.to_string()
}

pub fn get_default_keypair_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".config/solana/id.json")
}
